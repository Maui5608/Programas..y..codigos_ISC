# -*- coding: utf-8 -*-
"""Software generador de números pseudoaleatorios_Simulación.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1vcpixpaIpJoxAKWRRhJgLH54Vdo3z72K

**Software generador de números pseudoaleatorios**
"""

#Software generador de números pseudoaleatorios

#Materia: Simulación
#Docente: Dr. Holzen A. Martínez García

#Alumno: David Ezequiel Caballero González

#===================================================================================================#
class GeneradorPseudoAleatorio:
    def __init__(self, semilla):
      if not isinstance(semilla, int) or semilla < 0:
        raise ValueError("La semilla debe ser un número entero positivo.")
      self.semilla = semilla #Guarda la semilla en el objeto

#===================================================================================================#

    def cuadrados_medios(self, cantidad_n, semilla):  # Método simple de los cuadrados medios
      if cantidad_n <= 0:
        raise ValueError("La cantidad de números a generar debe ser un número positivo.")

      self.current_value = semilla  # Se movió fuera del `if`
      resultados = []
      num_digitos = len(str(semilla))

      for _ in range(cantidad_n):
        cuadrado = self.current_value ** 2  # Elevar al cuadrado
        cuadrado_str = str(cuadrado)  # Convertir a cadena

        # Si el número de dígitos del cuadrado es impar, agregar un '0' al inicio
        if len(cuadrado_str) % 2 != 0:
            cuadrado_str = "0" + cuadrado_str

        medio_i = (len(cuadrado_str) - num_digitos) // 2  # Índice para extraer los dígitos del centro
        medio = cuadrado_str[medio_i:medio_i + num_digitos]  # Extraer la parte central

        if medio.isdigit():  # Comprueba si la cadena medio está formada solo por números.
            self.current_value = int(medio)
        else:
            self.current_value = semilla  # Reiniciar si hay un problema

        resultados.append(int(medio))  # Convertimos `medio` a entero

      return resultados  # Ahora devolverá la lista correctamente

#===================================================================================================#

    def productos_medios(self, cantidad_n, semilla_1, semilla_2):  # Método simple de los productos medios
      if cantidad_n <= 0 or semilla_1 <= 0 or semilla_2 <= 0:
        raise ValueError("La cantidad de números a generar y las semillas deben ser números positivos.")

      self.current_value = semilla_1
      self.prev_value = semilla_2
      resultados = []
      num_digitos = len(str(semilla_1))

      for _ in range(cantidad_n):
        producto = self.prev_value * self.current_value  # Multiplicar el número anterior con el nuevo
        producto_str = str(producto)  # Convertir a cadena

        # Si el número de dígitos del cuadrado es impar, agregar un '0' al inicio
        if len(producto_str) % 2 != 0:
            producto_str = "0" + producto_str

        medio_i = (len(producto_str) - num_digitos) // 2  # Índice para extraer los dígitos del centro
        medio = producto_str[medio_i:medio_i + num_digitos]  # Extraer la parte central

        if medio.isdigit():  # Comprueba si la cadena medio está formada solo por números.
            self.current_value, self.prev_value = self.prev_value, int(medio)
        else:
            self.current_value, self.prev_value = self.prev_value, semilla_1  # Reiniciar en caso de error

        resultados.append(int(medio))  # Convertir a entero antes de agregarlo

      return resultados

#===================================================================================================#

    def multiplicador_constante(self, cantidad_n, semilla, constante):  # Método simple del multiplicador constante
      if cantidad_n <= 0 or semilla <= 0 or constante <= 0:
        raise ValueError("La cantidad de números a generar, la semilla y la constante deben ser números positivos.")

      self.current_value = semilla
      self.constante = constante
      resultados = []
      num_digitos = len(str(semilla))

      for _ in range(cantidad_n):
        producto = self.constante * self.current_value  # Multiplicar la constante con el número actual
        producto_str = str(producto)  # Convertir a cadena

        # Si el número de dígitos del resultado es impar, agregar un '0' al inicio
        if len(producto_str) % 2 != 0:
            producto_str = "0" + producto_str

        medio_i = (len(producto_str) - num_digitos) // 2  # Índice para extraer los dígitos del centro
        medio = producto_str[medio_i:medio_i + num_digitos]  # Extraer la parte central

        if medio.isdigit():  # Comprueba si la cadena medio está formada solo por números.
            self.current_value = int(medio)
        else:
            self.current_value = semilla  # Reiniciar en caso de error

        resultados.append(int(medio))  # Convertir a entero antes de agregarlo

      return resultados

#===================================================================================================#

    def congruencial_mixto(self, cantidad_n, a, c, m): #Método congruencial mixto(lineal)
      if cantidad_n <= 0 or a <= 0 or c < 0 or m <= 0:
        raise ValueError("La cantidad de números a generar, la constante multiplicativa, la constante aditiva y el módulo deben ser números positivos.")

      self.current_value = self.semilla
      resultados = []

      for _ in range(cantidad_n):
        self.current_value = (a * self.current_value + c) % m #Aplica la ecuación del método "Xi+1=(a * Xi + c) mod m"
        resultados.append(self.current_value)

      return resultados

#===================================================================================================#

    def congruencial_multiplicativo(self, cantidad_n, a, m): #Método congruencial multiplicativo
      if cantidad_n <= 0 or a <= 0 or m <= 0:
        raise ValueError("La cantidad de números a generar, la constante multiplicativa y el módulo deben ser números positivos.")

      self.current_value = self.semilla
      resultados = []

      for _ in range(cantidad_n):
        self.current_value = (a * self.current_value) % m #Aplica la ecuación del método "Xi+1=(a * Xi) mod m"
        resultados.append(self.current_value)

      return resultados

#===================================================================================================#

    def congruencial_aditivo(self, cantidad_n, semillas, m): #Método congruencial aditivo
      if cantidad_n <= 0 or m <= 0:
            raise ValueError("La cantidad de números y el módulo deben ser positivos.")
      if not all(isinstance(s, int) and s > 0 for s in semillas):
            raise ValueError("Todas las semillas deben ser enteros positivos.")

      resultados = semillas[:] #Copia las semillas iniciales
      n = len(semillas) #Valores iniciales

      for i in range(cantidad_n):
          nuevo_valor = (resultados[-1] + resultados[-n]) % m #Aplica la ecuación del método "Xi=(Xi−1 + Xi−n) mod m"

          resultados.append(nuevo_valor)

      return resultados[n:]

#===================================================================================================#

    def leer_entero(mensaje, minimo=1):
        """Solicita al usuario un número entero positivo."""
        while True:
            entrada = input(mensaje)
            if entrada.isdigit():
                numero = int(entrada)
                if numero >= minimo:
                    return numero
                else:
                    print(f"Error: el número debe ser mayor o igual a {minimo}.")
            else:
                print("Opción inválida, solo se permiten números enteros.")

#===================================================================================================#

def main():
    while True:
        print("\nSeleccione el método de generación de números pseudoaleatorios:")
        print("1. Cuadrados Medios")
        print("2. Productos Medios")
        print("3. Multiplicador Constante")
        print("4. Congruencial Mixto")
        print("5. Congruencial Multiplicativo")
        print("6. Congruencial Aditivo")
        print("7. Salir")

        choice = input("Ingrese su elección: ")
        if choice == '7':
            break
        if choice not in ['1', '2', '3', '4', '5', '6']:
            print("Opción inválida, intente nuevamente.")
            continue

        try:
            cantidad_n = int(input("Ingrese la cantidad de números a generar: "))
            semilla = int(input("Ingrese la semilla: "))
            generador = GeneradorPseudoAleatorio(semilla)

            if choice == '1':
                print(generador.cuadrados_medios(cantidad_n, semilla))
            elif choice == '2':
                semilla_2 = int(input("Ingrese la segunda semilla: "))
                print(generador.productos_medios(cantidad_n, semilla, semilla_2))
            elif choice == '3':
                constante = int(input("Ingrese la constante: "))
                print(generador.multiplicador_constante(cantidad_n, semilla, constante))
            elif choice == '4':
                a = int(input("Ingrese la constante multiplicativa (a): "))
                c = int(input("Ingrese la constante aditiva (c): "))
                m = int(input("Ingrese el módulo (m): "))
                print(generador.congruencial_mixto(cantidad_n, a, c, m,))
            elif choice == '5':
                a = int(input("Ingrese la constante multiplicativa (a): "))
                m = int(input("Ingrese el módulo (m): "))
                print(generador.congruencial_multiplicativo(cantidad_n, a, m))
            elif choice == '6':
                n = int(input("Ingrese la cantidad de valores iniciales (n): "))
                semillas = [int(input(f"Ingrese el valor inicial {i+1}: ")) for i in range(n)]
                m = int(input("Ingrese el módulo (m): "))
                print(generador.congruencial_aditivo(cantidad_n, semillas, m))
        except ValueError as e:
            print(f"Error: {e}")

if __name__ == "__main__":
    main()


#self.current_value, almacena el valor actual en la secuencia
#self.semilla, guarda la semilla inicial para reiniciar si hay un error
#self.prev_value, se usa solo en "Productos medios" para recordar el número anterior